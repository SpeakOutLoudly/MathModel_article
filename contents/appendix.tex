\chapter[附\hskip\ccwd{}\hskip\ccwd{}录]{{\heiti\zihao{3}附\hskip\ccwd{}\hskip\ccwd{}录}}

\section[\hspace{-2pt}支撑材料总览]{{\heiti\zihao{-3} \hspace{-8pt}支撑材料总览}}

本论文的所有支撑材料组织在\texttt{MathModel\_Code/}目录下，具体分类和说明如表\ref{table:supporting_materials}所示：

\begin{table}[h!]
\footnotesize
\setstretch{1.1}
\captionsetup{font={small, stretch=1.512}}
\centering
\bicaption[支撑材料分类说明]{支撑材料分类说明。}[Classification of Supporting Materials]{Classification of Supporting Materials.}
\begin{tabularx}{\textwidth}{p{1.8cm}p{4.2cm}X}
\toprule
材料类型 & 文件路径 & 说明 \\
\midrule
\multirow{3}{1.8cm}{实现代码} & \texttt{B/p1/p1.py} & 问题1：BT.2020到sRGB色域映射优化 \\
 & \texttt{B/p2/p2.py} & 问题2：四通道到五通道神经网络转换 \\
 & \texttt{B/p3/p3.py} & 问题3：LED显示器颜色校正算法 \\
\midrule
\multirow{4}{1.8cm}{原始数据} & \texttt{data/origin/xlsx/B题附件：RGB数值.xlsx} & 题目提供的原始RGB数值 \\
 & \texttt{data/preprocess/}\newline\texttt{RedPicture.xlsx} & 预处理后的红色基图数据 \\
 & \texttt{data/preprocess/}\newline\texttt{GreenPicture.xlsx} & 预处理后的绿色基图数据 \\
 & \texttt{data/preprocess/}\newline\texttt{BluePicture.xlsx} & 预处理后的蓝色基图数据 \\
\midrule
\multirow{9}{1.8cm}{结果图像} & \texttt{results/p1/DE2000.png} & 问题1：50次优化$\Delta E_{00}$分布 \\
 & \texttt{results/p1/色度.png} & 问题1：CIE1931色度图对比 \\
 & \texttt{results/p1/面积Loss.png} & 问题1：色域面积差异分析 \\
 & \texttt{results/p2/}\newline\texttt{Training\_Loss\_Curve.png} & 问题2：神经网络训练损失曲线 \\
 & \texttt{results/p2/}\newline\texttt{ΔE2000\_Error\_Histogram.png} & 问题2：色差误差分布直方图 \\
 & \texttt{results/p2/CDF.png} & 问题2：误差累积分布函数 \\
 & \texttt{results/p2/Sample.png} & 问题2：样本预测效果展示 \\
 & \texttt{results/p2/色度图.png} & 问题2：多基色色域可视化 \\
 & \texttt{results/p3/\{R,G,B\}.pdf} & 问题3：RGB三原色校正对比图 \\
\midrule
\multirow{2}{1.8cm}{环境配置} & \texttt{env.txt} & Python依赖包列表 \\
 & \texttt{mathmodel\_env.yaml} & Conda环境配置文件 \\
\midrule
说明文档 & \texttt{README.md} & 项目使用说明和运行指南 \\
\bottomrule
\end{tabularx}
\label{table:supporting_materials}
\end{table}

\lstset{
    basicstyle=\ttfamily\footnotesize,
    numbers=left,
    frame=single,
    backgroundcolor=\color{gray!10},
    showstringspaces=false,
    tabsize=2,
    captionpos=b,
    breaklines=true,                % 自动换行
    breakatwhitespace=false,        % 非空格处也能断行
    postbreak=\mbox{\textcolor{gray}{$\hookrightarrow$}\space},  % 换行标记
}
\section[\hspace{-2pt}问题1使用代码]{{\heiti\zihao{-3} \hspace{-8pt}问题1使用代码}}
\begin{lstlisting}[language=Python]
import warnings
warnings.filterwarnings("ignore")
import numpy as np
from scipy.optimize import differential_evolution
import matplotlib.pyplot as plt
import colour
from colormath.color_objects import LabColor, XYZColor
from colormath.color_conversions import convert_color

BT2020 = [[0.708, 0.292], [0.170, 0.797], [0.131, 0.046]]
sRGB_DP = [[0.64, 0.33], [0.30, 0.60], [0.15, 0.06]]
NTSC = [[0.67, 0.33], [0.21, 0.71], [0.14, 0.08]]

M_sRGB_to_XYZ = np.array([
    [0.4124564, 0.3575761, 0.1804375],
    [0.2126729, 0.7151522, 0.0721750],
    [0.0193339, 0.1191920, 0.9503041]
])

def lab_to_xyz_batch(lab_array):
    result = []
    for lab in lab_array:
        lab_color = LabColor(*lab)
        xyz_color = convert_color(lab_color, XYZColor)
        result.append([xyz_color.xyz_x, xyz_color.xyz_y, xyz_color.xyz_z])
    return np.array(result)

def rgb_to_xy(rgb, M_rgb_to_xyz):
    xyz = rgb @ M_rgb_to_xyz.T
    x = xyz[:, 0] / (xyz[:, 0] + xyz[:, 1] + xyz[:, 2])
    y = xyz[:, 1] / (xyz[:, 0] + xyz[:, 1] + xyz[:, 2])
    return np.stack([x, y], axis=1)

def xyz_to_xy_test(M_opt, RGB_basic, M_bt2020_to_xyz):
    # BT2020 to DP
    M_opt_inv = np.linalg.inv(M_opt)
    dp_rgb_mapped = (M_opt_inv @ RGB_basic.T).T  # shape (3, 3)
    BT2020_to_DP_mapped = rgb_to_xy(dp_rgb_mapped, M_bt2020_to_xyz)
    return BT2020_to_DP_mapped

def chromaticity_to_xyz_matrix(primaries, whitepoint):
    M = []
    for x, y in primaries:
        z = 1 - x - y
        M.append([x / y, 1.0, z / y])
    M = np.array(M).T
    Xw, Yw, Zw = whitepoint
    S = np.linalg.inv(M) @ np.array([Xw, Yw, Zw])
    return M * S

def delta_e_00_batch(lab1, lab2):
    lab1 = np.array(lab1)
    lab2 = np.array(lab2)
    
    L1, a1, b1 = lab1[:, 0], lab1[:, 1], lab1[:, 2]
    L2, a2, b2 = lab2[:, 0], lab2[:, 1], lab2[:, 2]

    avg_L = 0.5 * (L1 + L2)
    C1 = np.sqrt(a1**2 + b1**2)
    C2 = np.sqrt(a2**2 + b2**2)
    avg_C = 0.5 * (C1 + C2)

    G = 0.5 * (1 - np.sqrt((avg_C**7) / (avg_C**7 + 25**7)))
    a1p = (1 + G) * a1
    a2p = (1 + G) * a2
    C1p = np.sqrt(a1p**2 + b1**2)
    C2p = np.sqrt(a2p**2 + b2**2)
    avg_Cp = 0.5 * (C1p + C2p)

    h1p = np.degrees(np.arctan2(b1, a1p)) % 360
    h2p = np.degrees(np.arctan2(b2, a2p)) % 360

    deltahp = h2p - h1p
    deltahp = np.where(deltahp > 180, deltahp - 360, deltahp)
    deltahp = np.where(deltahp < -180, deltahp + 360, deltahp)

    delta_Hp = 2 * np.sqrt(C1p * C2p) * np.sin(np.radians(deltahp / 2))
    delta_Lp = L2 - L1
    delta_Cp = C2p - C1p

    avg_hp = np.where(np.abs(h1p - h2p) > 180, (h1p + h2p + 360) / 2, (h1p + h2p) / 2)
    T = 1 - 0.17 * np.cos(np.radians(avg_hp - 30)) + 0.24 * np.cos(np.radians(2 * avg_hp)) \
        + 0.32 * np.cos(np.radians(3 * avg_hp + 6)) - 0.20 * np.cos(np.radians(4 * avg_hp - 63))

    delta_theta = 30 * np.exp(-((avg_hp - 275) / 25)**2)
    Rc = 2 * np.sqrt((avg_Cp**7) / (avg_Cp**7 + 25**7))
    Sl = 1 + (0.015 * (avg_L - 50)**2) / np.sqrt(20 + (avg_L - 50)**2)
    Sc = 1 + 0.045 * avg_Cp
    Sh = 1 + 0.015 * avg_Cp * T
    Rt = -np.sin(np.radians(2 * delta_theta)) * Rc

    delta_E = np.sqrt(
        (delta_Lp / Sl)**2 +
        (delta_Cp / Sc)**2 +
        (delta_Hp / Sh)**2 +
        Rt * (delta_Cp / Sc) * (delta_Hp / Sh)
    )

    return delta_E

def f(t):
    delta = 6/29
    return np.where(t > delta**3, np.cbrt(t), (t / (3 * delta**2)) + (4/29))

def xyz_to_lab_batch(xyz, white_point=(0.95047, 1.00000, 1.08883)):
    Xn, Yn, Zn = white_point
    X = xyz[:, 0] / Xn
    Y = xyz[:, 1] / Yn
    Z = xyz[:, 2] / Zn

    fx = f(X)
    fy = f(Y)
    fz = f(Z)

    L = 116 * fy - 16
    a = 500 * (fx - fy)
    b = 200 * (fy - fz)

    return np.stack([L, a, b], axis=1)

def combined_loss(M_flat, rgb_samples, M_bt2020_to_xyz, M_dp_to_xyz, xyz_to_lab_batch):

    # 变换矩阵
    M = M_flat.reshape(3, 3)
    
    # ===== ΔE00 感知损失 =====
    rgb_dp = rgb_samples @ M.T
    rgb_dp = np.clip(rgb_dp, 0, 1)

    xyz_pred = rgb_dp @ M_dp_to_xyz.T
    lab_pred = xyz_to_lab_batch(xyz_pred)

    xyz_true = rgb_samples @ M_bt2020_to_xyz.T
    lab_true = xyz_to_lab_batch(xyz_true)

    deltaE = delta_e_00_batch(lab_true, lab_pred)
    color_loss = np.mean(deltaE)

    return color_loss 

def optimize_model_N_times(whitepoint, sRGB_DP, M_flat_init, M_bt2020_to_xyz, M_dp_to_xyz, xyz_to_lab_batch,
                           N=10, method='DE', random_seed_offset=31):
    """
    对比不同优化器在 N 轮随机样本下的表现

    参数：
    - M_flat_init: 初始 M（flatten）
    - M_bt2020_to_xyz: BT2020 → XYZ 变换矩阵
    - M_dp_to_xyz: DP → XYZ 变换矩阵
    - xyz_to_lab_batch: XYZ → Lab 转换函数（批量）
    - N: 循环次数
    - method: 优化方法选择，'L-BFGS-B' 或 'DE'
    - random_seed_offset: 随机种子偏移量，确保每轮样本不同但可复现

    返回：
    - losses: ndarray[N]，每轮优化得到的 loss
    """

    losses = []
    area_diffs = []
    RGB_basic = np.eye(3)
    ref_area = triangle_area(sRGB_DP)

    for i in range(N):
        seed = i + random_seed_offset
        np.random.seed(seed)
        test_samples = np.random.rand(100, 3)

        def loss_fn(M_flat):
            return combined_loss(M_flat, test_samples, M_bt2020_to_xyz, M_dp_to_xyz, xyz_to_lab_batch)

        if method == 'DE':
            bounds = [(-2, 2)] * 9
            res = differential_evolution(
                loss_fn,
                bounds,
                strategy='best1bin',
                maxiter=1000,
                polish=True,
                seed=seed
            )
        else:
            raise ValueError(f"Unknown method: {method}. Supported: 'DE'")

        M_opt = res.x.reshape(3, 3)
        # ===========================
        BT2020_to_DP_mapped = xyz_to_xy_test(M_opt, RGB_basic, M_bt2020_to_xyz)
        BT_mapped_xyz = chromaticity_to_xyz_matrix(BT2020_to_DP_mapped, whitepoint)
        BT_mapped_lab = xyz_to_lab_batch(BT_mapped_xyz)
        BT_lab = xyz_to_lab_batch(M_sRGB_to_XYZ)
        loss = np.mean(delta_e_00_batch(BT_mapped_lab, BT_lab))
        # ===========================
        # final_loss = loss_fn(res.x)
        losses.append(loss)

        triangle_xy = xyz_to_xy_test(M_opt, RGB_basic, M_bt2020_to_xyz)
        area = triangle_area(triangle_xy)
        area_diff = abs(area - ref_area)
        area_diffs.append(area_diff)

    return np.array(losses), np.array(area_diffs)

def triangle_area(pts):
    """
    计算三角形面积：pts 是 3x2 的 xy 坐标矩阵
    使用 Shoelace formula（鞋带公式）
    """
    pts = np.array(pts)
    x = pts[:, 0]
    y = pts[:, 1]
    return 0.5 * abs(x[0]*(y[1]-y[2]) + x[1]*(y[2]-y[0]) + x[2]*(y[0]-y[1]))


def plot_chromaticity_with_triangles(example_dict):
    """
    在 CIE 1931 xy 色度图上叠加多个 RGB 三角形。
    前两个三角形为实线，后续为虚线，图例使用变量名。
    """
    figure, axes = colour.plotting.plot_chromaticity_diagram_CIE1931(standalone=False)

    colors = plt.rcParams['axes.prop_cycle'].by_key()['color']
    linestyle_solid = '-'
    linestyle_dashed = '--'

    for i, (label, triangle) in enumerate(example_dict.items()):
        triangle = np.array(triangle)
        polygon = np.vstack([triangle, triangle[0]])
        linestyle = linestyle_solid if i < 2 else linestyle_dashed

        axes.plot(polygon[:, 0], polygon[:, 1],
                  color=colors[i % len(colors)],
                  linewidth=2,
                  linestyle=linestyle,
                  label=label)

    axes.legend()
    axes.set_title("CIE 1931 Chromaticity Diagram with RGB Triangles")
    plt.grid(True)
    plt.show()


def plot_loss_statistics(losses, title='Loss Distribution', method_name='L-BFGS-B'):
    """
    绘制柱状图并显示统计信息。

    参数：
    - losses: 一维 ndarray，优化 N 次的 loss 值
    - title: 图表标题
    - method_name: 优化方法名称，用于图表显示
    """

    # 计算统计量
    mean_loss = np.mean(losses)
    min_loss = np.min(losses)
    std_loss = np.std(losses)

    # 创建柱状图
    plt.figure(figsize=(10, 6))
    bars = plt.bar(range(len(losses)), losses, color='skyblue', edgecolor='black')

    # 高亮最小值
    min_index = np.argmin(losses)
    bars[min_index].set_color('orange')

    # 标注统计量
    plt.axhline(mean_loss, color='red', linestyle='--', label=f'Mean: {mean_loss:.4f}')
    plt.axhline(min_loss, color='green', linestyle='--', label=f'Min: {min_loss:.4f}')
    plt.text(len(losses) - 1, mean_loss + 0.05, f'σ: {std_loss:.4f}', color='red', fontsize=10, ha='right')

    # 图形美化
    plt.title(f'{title} ({method_name})', fontsize=14)
    plt.xlabel('Trial Index')
    plt.ylabel('Loss Value')
    plt.xticks(range(len(losses)))
    plt.legend()
    plt.grid(True, linestyle='--', alpha=0.5)

    plt.tight_layout()
    plt.show()

if __name__ =="__main__":
    # D65 whitepoint in XYZ
    whitepoint = (0.3127 / 0.3290, 1.0, (1 - 0.3127 - 0.3290) / 0.3290)
    # BT2020 → XYZ
    M_bt2020_to_xyz = chromaticity_to_xyz_matrix(BT2020, whitepoint)
    # DP/sRGB → XYZ
    M_dp_to_xyz = chromaticity_to_xyz_matrix(sRGB_DP, whitepoint)

    # =============== 训练部分 ===============
    # 采样一组 BT.2020 RGB 样本 {c_i}
    M0 = np.eye(3).flatten()
    M0_flat = np.eye(3).flatten()

    # L-BFGS-B 优化 50 次
    losses_lbfgs, area_diffs = optimize_model_N_times(
        whitepoint,
        sRGB_DP,
        M0_flat,
        M_bt2020_to_xyz,
        M_dp_to_xyz,
        xyz_to_lab_batch,
        N=50,
        method='DE'
    )
    print("DE Losses:", losses_lbfgs)

    plot_loss_statistics(losses_lbfgs, title='DE Distribution', method_name='Differential Evolution')
    plot_loss_statistics(area_diffs, title='Chromaticity Area Difference', method_name='Differential Evolution')
    # ============== 单独测试 ==============
    np.random.seed(35)
    test_samples = np.random.rand(100, 3)
    bounds = [(-2, 2)] * 9
    def loss_fn(M_flat):
        return combined_loss(M_flat, test_samples, M_bt2020_to_xyz, M_dp_to_xyz, xyz_to_lab_batch)
    
    res1 = differential_evolution(
        loss_fn,
        bounds,
        strategy='best1bin',
        maxiter=1000,
        polish=True,
        seed=35,
        )
    M_opt = res1.x.reshape(3, 3)
    # 映射到色度图上
    # DB to BT2020
    RGB_basic = np.eye(3)
    # BT2020 to DP
    BT2020_to_DP_mapped = xyz_to_xy_test(M_opt, RGB_basic, M_bt2020_to_xyz)

    examples = {
        "BT2020": BT2020,
        "sRGB_DP": sRGB_DP,
        "BT2020_to_DP_mapped": BT2020_to_DP_mapped
    }

    plot_chromaticity_with_triangles(examples)

\end{lstlisting}

\section[\hspace{-2pt}问题2使用代码]{{\heiti\zihao{-3} \hspace{-8pt}问题2使用代码}}
\begin{lstlisting}[language=Python]
import torch
import torch.nn as nn
import torch.optim as optim
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from scipy.spatial import ConvexHull
import colour

# 定义RGB到XYZ的PyTorch函数
def rgb_to_xyz_torch(rgb):
    device = rgb.device
    # sRGB到XYZ的转换矩阵
    M = torch.tensor([
        [0.4124564, 0.3575761, 0.1804375],
        [0.2126729, 0.7151522, 0.0721750],
        [0.0193339, 0.1191920, 0.9503041]
    ], device=device, dtype=torch.float32)
    # sRGB到线性RGB的转换，处理Gamma校正
    mask = rgb > 0.04045
    rgb_linear = torch.where(mask,
                             torch.pow((rgb + 0.055) / 1.055, 2.4),
                             rgb / 12.92)
    # 矩阵乘法完成转换
    return torch.matmul(rgb_linear, M.T)

# 定义XYZ到Lab的PyTorch函数
def xyz_to_lab_torch(xyz):
    device = xyz.device
    # D65白点
    white = torch.tensor([0.95047, 1.00000, 1.08883], device=device, dtype=torch.float32)
    # XYZ值相对于白点进行缩放
    xyz_scaled = xyz / white
    delta = 6.0 / 29.0
    # 定义Lab转换中的f函数
    def f(t):
        return torch.where(t > delta**3,
                           torch.pow(t, 1.0/3.0),
                           t / (3.0 * delta**2) + 4.0 / 29.0)
    # 应用f函数到XYZ的每个分量
    f_xyz = f(xyz_scaled)
    # 计算L*, a*, b*分量
    L = 116.0 * f_xyz[..., 1] - 16.0
    a = 500.0 * (f_xyz[..., 0] - f_xyz[..., 1])
    b = 200.0 * (f_xyz[..., 1] - f_xyz[..., 2])
    # 堆叠L, a, b分量
    return torch.stack([L, a, b], dim=-1)

# 定义RGB到Lab的PyTorch函数
def rgb_to_lab_torch(rgb):
    # 添加一个小的epsilon防止log(0)或者除以0的情况
    return xyz_to_lab_torch(rgb_to_xyz_torch(rgb.clamp(min=1e-8)))

# 定义DeltaE2000颜色差异的PyTorch函数
def deltaE2000_torch(lab1, lab2):
    L1, a1, b1 = lab1[..., 0], lab1[..., 1], lab1[..., 2]
    L2, a2, b2 = lab2[..., 0], lab2[..., 1], lab2[..., 2]

    # k_L, k_C, k_H 是权重因子，通常设为1
    k_L, k_C, k_H = 1.0, 1.0, 1.0

    # 计算CIE Lab中的色度C
    C1 = torch.sqrt(a1**2 + b1**2)
    C2 = torch.sqrt(a2**2 + b2**2)

    # 计算平均色度
    avg_C = (C1 + C2) / 2.0

    # 计算G因子，用于修正a'值
    G = 0.5 * (1 - torch.sqrt(avg_C**7 / (avg_C**7 + 25**7)))

    # 修正a'值
    a1p = (1 + G) * a1
    a2p = (1 + G) * a2

    # 计算修正后的色度C'
    C1p = torch.sqrt(a1p**2 + b1**2)
    C2p = torch.sqrt(a2p**2 + b2**2)

    # 计算色相角h' (以度为单位)
    h1p = torch.rad2deg(torch.atan2(b1, a1p))
    h1p = torch.where(h1p < 0, h1p + 360, h1p) # 确保角度在0-360度
    h2p = torch.rad2deg(torch.atan2(b2, a2p))
    h2p = torch.where(h2p < 0, h2p + 360, h2p)

    # 计算平均亮度L*
    avg_L = (L1 + L2) / 2.0
    # 计算平均修正色度C'*
    avg_Cp = (C1p + C2p) / 2.0

    # 计算色相角差Δh'
    h_diff = h2p - h1p
    delta_hp = torch.where(torch.abs(h_diff) <= 180, h_diff, h_diff - 360 * torch.sign(h_diff))

    # 计算亮度差ΔL'，色度差ΔC'，色相差ΔH'
    Delta_Lp = L2 - L1
    Delta_Cp = C2p - C1p
    Delta_hp = 2 * torch.sqrt(C1p * C2p) * torch.sin(torch.deg2rad(delta_hp / 2.0))

    # 计算平均色相角h' (特殊处理)
    h_sum = h1p + h2p
    avg_hp = torch.where(torch.abs(h_diff) > 180, (h_sum + 360) / 2, h_sum / 2)

    # 计算T因子
    T = (1 - 0.17 * torch.cos(torch.deg2rad(avg_hp - 30)) +
         0.24 * torch.cos(torch.deg2rad(2 * avg_hp)) +
         0.32 * torch.cos(torch.deg2rad(3 * avg_hp + 6)) -
         0.20 * torch.cos(torch.deg2rad(4 * avg_hp - 63)))

    # 计算Δθ因子 (旋转项)
    delta_ro = 30 * torch.exp(-((avg_hp - 275) / 25)**2)

    # 计算色度权重Rc
    R_C = 2 * torch.sqrt(avg_Cp**7 / (avg_Cp**7 + 25**7))
    # 计算亮度权重Sl
    S_L = 1 + (0.015 * (avg_L - 50)**2) / torch.sqrt(20 + (avg_L - 50)**2)
    # 计算色度权重Sc
    S_C = 1 + 0.045 * avg_Cp
    # 计算色相权重Sh
    S_H = 1 + 0.015 * avg_Cp * T
    # 计算旋转项Rt
    R_T = -torch.sin(torch.deg2rad(2 * delta_ro)) * R_C

    # 最终的DeltaE2000公式
    delta_E = torch.sqrt(
        (Delta_Lp / (k_L * S_L))**2 +
        (Delta_Cp / (k_C * S_C))**2 +
        (Delta_hp / (k_H * S_H))**2 +
        R_T * (Delta_Cp / (k_C * S_C)) * (Delta_hp / (k_H * S_H))
    )

    return delta_E

# 定义一个结合MSE和DeltaE2000的混合损失函数
class CombinedLoss(nn.Module):

    def __init__(self, alpha=0.1, beta=1.0):
        super().__init__()
        self.alpha = alpha # MSE损失的权重
        self.beta = beta   # DeltaE2000损失的权重
        self.mse_loss = nn.MSELoss() # 初始化MSE损失

    def forward(self, pred_rgbcx, target_rgbcx):
        # 对所有5个通道计算MSE损失
        loss_mse = self.mse_loss(pred_rgbcx, target_rgbcx)

        # 对前3个通道（RGB）计算DeltaE2000损失
        pred_rgb = pred_rgbcx[:, :3]
        target_rgb = target_rgbcx[:, :3]

        # 将RGB转换为Lab颜色空间
        pred_lab = rgb_to_lab_torch(pred_rgb)
        target_lab = rgb_to_lab_torch(target_rgb)

        # 计算DeltaE2000损失的平均值
        loss_delta_e = torch.mean(deltaE2000_torch(pred_lab, target_lab))

        # 结合两种损失
        total_loss = self.alpha * loss_mse + self.beta * loss_delta_e
        return total_loss

# 定义RGB到XYZ的NumPy函数 (与PyTorch版本对应)
def rgb_to_xyz(rgb):
    mask = rgb > 0.04045
    rgb_linear = np.where(mask, ((rgb + 0.055)/1.055)**2.4, rgb / 12.92)
    M = np.array([[0.4124564, 0.3575761, 0.1804375],
                  [0.2126729, 0.7151522, 0.0721750],
                  [0.0193339, 0.1191920, 0.9503041]])
    return np.dot(rgb_linear, M.T)

# 定义XYZ到Lab的NumPy函数 (与PyTorch版本对应)
def xyz_to_lab(xyz):
    white = np.array([0.95047, 1.00000, 1.08883])
    xyz_scaled = xyz / white
    def f(t):
        delta = 6/29
        return np.where(t > delta**3, np.cbrt(t), t/(3*delta**2) + 4/29)
    f_xyz = f(xyz_scaled)
    L = 116*f_xyz[...,1] - 16
    a = 500*(f_xyz[...,0] - f_xyz[...,1])
    b = 200*(f_xyz[...,1] - f_xyz[...,2])
    return np.stack([L,a,b], axis=-1)

# 定义RGB到Lab的NumPy函数 (与PyTorch版本对应)
def rgb_to_lab(rgb):
    return xyz_to_lab(rgb_to_xyz(np.clip(rgb, 0, 1)))

# 定义DeltaE2000颜色差异的NumPy函数 (与PyTorch版本对应)
def deltaE2000(Lab1, Lab2):
    L1, a1, b1 = Lab1[...,0], Lab1[...,1], Lab1[...,2]
    L2, a2, b2 = Lab2[...,0], Lab2[...,1], Lab2[...,2]
    avg_L = 0.5 * (L1 + L2)
    C1 = np.sqrt(a1**2 + b1**2)
    C2 = np.sqrt(a2**2 + b2**2)
    avg_C = 0.5 * (C1 + C2)
    G = 0.5 * (1 - np.sqrt((avg_C**7) / (avg_C**7 + 25**7)))
    a1p = (1 + G) * a1
    a2p = (1 + G) * a2
    C1p = np.sqrt(a1p**2 + b1**2)
    C2p = np.sqrt(a2p**2 + b2**2) # 修正: b2p应该是b2
    h1p = np.degrees(np.arctan2(b1, a1p)) % 360
    h2p = np.degrees(np.arctan2(b2, a2p)) % 360
    delta_Lp = L2 - L1
    delta_Cp = C2p - C1p
    dhp = h2p - h1p
    dhp = np.where(np.abs(dhp) > 180, dhp - 360 * np.sign(dhp), dhp)
    delta_hp = 2 * np.sqrt(C1p * C2p) * np.sin(np.radians(dhp / 2))
    avg_Lp = (L1 + L2) / 2
    avg_Cp = (C1p + C2p) / 2
    hp_sum = h1p + h2p
    avg_hp = np.where(np.abs(h1p - h2p) > 180, (hp_sum + 360) / 2, hp_sum / 2)
    T = 1 - 0.17*np.cos(np.radians(avg_hp - 30)) + \
        0.24*np.cos(np.radians(2*avg_hp)) + \
        0.32*np.cos(np.radians(3*avg_hp + 6)) - \
        0.20*np.cos(np.radians(4*avg_hp - 63))
    delta_ro = 30 * np.exp(-((avg_hp - 275)/25)**2)
    Rc = 2 * np.sqrt((avg_Cp**7) / (avg_Cp**7 + 25**7))
    Sl = 1 + ((0.015 * (avg_Lp - 50)**2) / np.sqrt(20 + (avg_Lp - 50)**2))
    Sc = 1 + 0.045 * avg_Cp
    Sh = 1 + 0.015 * avg_Cp * T
    Rt = -np.sin(np.radians(2 * delta_ro)) * Rc
    delta_E = np.sqrt(
        (delta_Lp / Sl)**2 +
        (delta_Cp / Sc)**2 +
        (delta_hp / Sh)**2 +
        Rt * (delta_Cp / Sc) * (delta_hp / Sh))
    return delta_E

# 定义神经网络模型 ColorNet
class ColorNet(nn.Module):
    def __init__(self):
        super(ColorNet, self).__init__()
        # 定义一个简单的全连接神经网络
        self.net = nn.Sequential(
            nn.Linear(4, 64), # 输入4通道 (RGBV)
            nn.ReLU(),
            nn.Linear(64, 128),
            nn.ReLU(),
            nn.Linear(128, 64),
            nn.ReLU(),
            nn.Linear(64, 5), # 输出5通道 (RGBCX)
            nn.Sigmoid() # 输出值在0-1之间
        )
    def forward(self, x):
        return self.net(x)

# 生成训练数据
def generate_train_data(n_samples=2000):
    # X是相机输入 RGBV (4通道)
    X = np.random.rand(n_samples, 4).astype(np.float32)

    # 定义一个简单线性变换矩阵 W，模拟相机对不同通道光的响应
    W = np.array([
        [0.9, 0.05, 0.03, 0.02],    # R_out = 0.9*R_in + 0.05*G_in + ...
        [0.05, 0.85, 0.05, 0.05],   # G_out
        [0.02, 0.03, 0.9, 0.05],    # B_out
        [0.01, 0.02, 0.03, 0.9],    # C_out (受V通道影响较大)
        [0.02, 0.05, 0.02, 0.91]    # X_out (受V通道影响较大)
    ], dtype=np.float32)

    Y_linear = X.dot(W.T) # 线性变换
    # 加入非线性扰动，使模型学习更复杂的映射
    Y_nonlinear = Y_linear + 0.02 * np.sin(5 * np.pi * X[:, 0:1])
    Y_nonlinear = np.clip(Y_nonlinear, 0, 1) # 确保颜色值在0-1范围内
    return X, Y_nonlinear.astype(np.float32)

# 训练模型
def train_model(X, Y, epochs=100, batch_size=32, lr=1e-3):
    # 设置设备为GPU（如果可用）或CPU
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    model = ColorNet().to(device) # 将模型移到指定设备
    optimizer = optim.AdamW(model.parameters(), lr=lr) # 使用AdamW优化器
    # 划分训练集和验证集
    X_train, X_val, Y_train, Y_val = train_test_split(X, Y, test_size=0.2, random_state=42)
    train_losses, val_losses = [], []

    loss_fn = CombinedLoss(alpha=0.1, beta=1.0).to(device) # 初始化混合损失函数

    for epoch in range(epochs):
        model.train() # 设置模型为训练模式
        permutation = np.random.permutation(len(X_train)) # 随机打乱训练数据
        epoch_loss = 0
        for i in range(0, len(X_train), batch_size):
            indices = permutation[i:i+batch_size]
            batch_x = torch.tensor(X_train[indices], dtype=torch.float32, device=device)
            batch_y = torch.tensor(Y_train[indices], dtype=torch.float32, device=device)

            optimizer.zero_grad() # 梯度清零
            outputs = model(batch_x) # 前向传播

            loss = loss_fn(outputs, batch_y) # 计算损失

            loss.backward() # 反向传播
            optimizer.step() # 更新模型参数
            epoch_loss += loss.item() * len(indices)
        avg_train_loss = epoch_loss / len(X_train)
        train_losses.append(avg_train_loss)

        model.eval() # 设置模型为评估模式
        with torch.no_grad(): # 禁用梯度计算
            val_x = torch.tensor(X_val, dtype=torch.float32, device=device)
            val_y = torch.tensor(Y_val, dtype=torch.float32, device=device)
            val_pred = model(val_x)

            val_loss = loss_fn(val_pred, val_y).item()
        val_losses.append(val_loss)

        if (epoch + 1) % 10 == 0 or epoch == 0:
            print(f"Epoch {epoch+1}/{epochs} - Train Loss: {avg_train_loss:.6f} - Val Loss: {val_loss:.6f}")

    return model, train_losses, val_losses, X_val, Y_val

# 可视化DeltaE2000误差分布
def visualize_errors(model, X_val, Y_val):
    device = next(model.parameters()).device
    model.eval() # 设置模型为评估模式
    with torch.no_grad(): # 禁用梯度计算
        inputs = torch.tensor(X_val, dtype=torch.float32, device=device)
        outputs = model(inputs).cpu().numpy() # 获取模型输出并转为NumPy数组
        targets = Y_val

    pred_rgb = outputs[:, :3] # 提取预测的RGB分量
    target_rgb = targets[:, :3] # 提取目标的RGB分量

    # 将RGB转换为Lab，并计算DeltaE2000
    pred_lab = rgb_to_lab(pred_rgb)
    target_lab = rgb_to_lab(target_rgb)
    delta_e = deltaE2000(pred_lab, target_lab)

    plt.figure(figsize=(6,4))
    plt.hist(delta_e, bins=50, color='skyblue', range=(0, max(5, np.max(delta_e))))
    plt.title('ΔE2000 Error Histogram (Trained with Hybrid Loss)')
    plt.xlabel('ΔE2000')
    plt.ylabel('Pixel Count')
    plt.show()

    sorted_de = np.sort(delta_e)
    cdf = np.arange(len(sorted_de)) / float(len(sorted_de))

    plt.figure(figsize=(6,4))
    plt.plot(sorted_de, cdf, color='green')
    plt.title('CDF of ΔE2000 Error (Trained with Hybrid Loss)')
    plt.xlabel('ΔE2000')
    plt.ylabel('Cumulative Probability')
    plt.grid(True)
    plt.show()

# 绘制色度图和色域三角形
def plot_chromaticity_with_triangles(example_dict):
    # 使用colour库绘制CIE 1931色度图
    figure, axes = colour.plotting.plot_chromaticity_diagram_CIE1931(standalone=False)

    colors = plt.rcParams['axes.prop_cycle'].by_key()['color']
    linestyle_solid = '-'
    linestyle_dashed = '--'

    # 遍历字典中的每个色域并绘制
    for i, (label, triangle) in enumerate(example_dict.items()):
        triangle = np.array(triangle)

        # 闭合多边形以绘制三角形
        polygon = np.vstack([triangle, triangle[0]])
        linestyle = linestyle_solid if i < 2 else linestyle_dashed # 前两个用实线，后面用虚线

        # 绘制色域边界
        axes.plot(polygon[:, 0], polygon[:, 1],
                  color=colors[i % len(colors)],
                  linewidth=2,
                  linestyle=linestyle,
                  label=label)

        # 绘制每个基色点
        point_labels = ['R', 'G', 'B', 'V'] if 'Input' in label else ['R', 'G', 'C', 'B', 'X']
        for j, point in enumerate(triangle):
            axes.scatter(point[0], point[1], color=colors[i % len(colors)], s=70, zorder=5, edgecolors='black')
            # 标记基色点
            axes.text(point[0] + 0.005, point[1] + 0.005, f'{point_labels[j]}', fontsize=10, color='black')

    axes.legend() # 显示图例
    axes.set_title("CIE 1931 Chromaticity Diagram with Multi-Primary Gamuts")
    plt.grid(True)
    plt.show()

# 辅助函数：将RGBV数据转换为用于显示的RGB
def _rgbv_to_rgb_display(rgbv):
    if rgbv.ndim == 1: # 如果是单个样本
        r, g, b, v = rgbv
    else: # 如果是批量样本
        r, g, b, v = rgbv[:, 0], rgbv[:, 1], rgbv[:, 2], rgbv[:, 3]

    # 简单的融合V通道到RGB，用于可视化
    r_display = np.clip(r + v * 0.1, 0, 1)
    g_display = np.clip(g, 0, 1)
    b_display = np.clip(b + v * 0.2, 0, 1)

    return np.stack([r_display, g_display, b_display], axis=-1)

# 辅助函数：将RGBCX数据转换为用于显示的RGB
def _rgbcx_to_rgb_display(rgbcx):
    if rgbcx.ndim == 1: # 如果是单个样本
        r, g, b, c, x = rgbcx
    else: # 如果是批量样本
        r, g, b, c, x = rgbcx[:, 0], rgbcx[:, 1], rgbcx[:, 2], rgbcx[:, 3], rgbcx[:, 4]

    # 简化的C和X通道融合到RGB，用于可视化
    # C (Cyan) 影响 G 和 B
    # X (Extra Red) 影响 R
    r_display = np.clip(r + x * 0.3, 0, 1) # X通道增加红色
    g_display = np.clip(g + c * 0.2, 0, 1) # C通道增加绿色
    b_display = np.clip(b + c * 0.3, 0, 1) # C通道增加蓝色

    return np.stack([r_display, g_display, b_display], axis=-1)

# 可视化部分样本的预测结果
def visualize_sample_predictions(model, X_val, Y_val, num_samples=5):
    device = next(model.parameters()).device
    model.eval() # 设置模型为评估模式

    # 随机选择num_samples个样本
    indices = np.random.choice(len(X_val), num_samples, replace=False)

    fig, axes = plt.subplots(num_samples, 3, figsize=(9, 2 * num_samples))
    fig.suptitle('Sample Color Predictions (Input RGBV -> Output RGBCX)', fontsize=16)

    for i, idx in enumerate(indices):
        input_rgbv = X_val[idx]
        target_rgbcx = Y_val[idx]

        # 模型预测
        with torch.no_grad():
            pred_rgbcx_tensor = model(torch.tensor(input_rgbv, dtype=torch.float32, device=device).unsqueeze(0))
            pred_rgbcx = pred_rgbcx_tensor.squeeze(0).cpu().numpy() # 获取预测结果并转为NumPy数组

        # 将RGBV转换为RGB用于显示（简化处理）
        display_input_rgb = _rgbv_to_rgb_display(input_rgbv)

        # 将RGBCX转换为RGB用于显示（简化处理）
        display_target_rgb = _rgbcx_to_rgb_display(target_rgbcx)
        display_pred_rgb = _rgbcx_to_rgb_display(pred_rgbcx)

        # 计算显示用的RGB之间的DeltaE2000
        delta_e = deltaE2000(rgb_to_lab(display_pred_rgb), rgb_to_lab(display_target_rgb))

        # 绘制输入、目标和预测的颜色块
        ax = axes[i, 0]
        ax.imshow([[display_input_rgb]]) # imshow需要2D数组，所以用[[color]]
        ax.set_title(f'Input (RGBV)\nSample {idx}', fontsize=8)
        ax.axis('off')

        ax = axes[i, 1]
        ax.imshow([[display_target_rgb]])
        ax.set_title(f'Target (RGBCX->RGB)', fontsize=8)
        ax.axis('off')

        ax = axes[i, 2]
        ax.imshow([[display_pred_rgb]])
        ax.set_title(f'Predicted (RGBCX->RGB)\nΔE2000: {delta_e:.2f}', fontsize=8)
        ax.axis('off')

    plt.tight_layout(rect=[0, 0.03, 1, 0.95]) # 调整布局
    plt.savefig('sample_predictions.png', dpi=300) # 保存图片
    plt.show()

# 主程序
if __name__ == '__main__':
    X, Y = generate_train_data(n_samples=4000) # 生成训练数据

    # 训练模型
    model, train_losses, val_losses, X_val, Y_val = train_model(X, Y, epochs=200, lr=5e-4)

    # 绘制训练损失和验证损失曲线
    plt.plot(train_losses, label='Train Loss')
    plt.plot(val_losses, label='Validation Loss')
    plt.xlabel('Epoch')
    plt.ylabel('Combined Loss (0.1*MSE + 1.0*ΔE2000)')
    plt.legend()
    plt.title('Training Loss Curve (Hybrid Loss)')
    plt.show()

    # 定义标准sRGB的R,G,B基色坐标
    PRIMARY_R = [0.64, 0.33]
    PRIMARY_G = [0.30, 0.60]
    PRIMARY_B = [0.15, 0.06]

    # 定义相机新增的 'V' (Violet/紫色) 基色坐标
    # 选择一个在蓝色和光谱轨迹紫色区域之间的点
    PRIMARY_V = [0.16, 0.03]

    # 定义LED屏新增的 'C' (Cyan/青色) 和 'X' (假设为一种更深的红色) 基色坐标
    # 选择一个能扩展蓝绿边界的青色点
    PRIMARY_C = [0.18, 0.45]
    # 选择一个比sRGB的R更红的点，以扩展红色边界
    PRIMARY_X = [0.70, 0.30]

    # 组合成输入和输出系统的基色字典
    input_system_primaries_coords = {
        'RGBV Input Gamut': [PRIMARY_R, PRIMARY_G, PRIMARY_B, PRIMARY_V]
    }

    output_system_primaries_coords = {
        'RGBCX Output Gamut': [PRIMARY_R, PRIMARY_G, PRIMARY_C, PRIMARY_B, PRIMARY_X]
    }

    # 合并所有色域数据用于绘图
    all_gamuts_for_plotting = {**input_system_primaries_coords, **output_system_primaries_coords}

    # 可视化DeltaE2000误差分布
    visualize_errors(model, X_val, Y_val)

    # 绘制色度图和色域三角形
    plot_chromaticity_with_triangles(all_gamuts_for_plotting)

    # 可视化部分样本的预测效果
    visualize_sample_predictions(model, X_val, Y_val, num_samples=8)
\end{lstlisting}

\section[\hspace{-2pt}问题3使用代码]{{\heiti\zihao{-3} \hspace{-8pt}问题3使用代码}}
\begin{lstlisting}[language=Python]
    import numpy as np
    import matplotlib.pyplot as plt
    import pandas as pd
    from scipy.optimize import minimize, differential_evolution
    
    # 设置中文字体
    plt.rcParams['font.sans-serif'] = ['SimHei', 'DejaVu Sans']
    plt.rcParams['axes.unicode_minus'] = False
    
    class LEDColorCorrection:
        """
        基于三基色原理和CIE Lab色彩空间的颜色校正
        使用差分进化算法优化校正矩阵
        """
        
        def __init__(self):
            self.correction_matrix = None
            self.correction_bias = None
            self.gamma_correction = None
            self.measured_data = None
            self.target_data = None
            
        def load_excel_data(self, excel_path):
            """从Excel文件加载数据"""
            print(f"正在加载Excel文件: {excel_path}")
            
            sheets = ['R', 'G', 'B', 'target_R', 'target_G', 'target_B']
            data_dict = {}
            
            for sheet_name in sheets:
                df = pd.read_excel(excel_path, sheet_name=sheet_name, header=None).iloc[0:64,0:64]
                data_dict[sheet_name] = df.values
                print(f"已加载工作表 '{sheet_name}': {df.shape}")
            
            # 组织数据
            self.measured_data = np.stack([
                data_dict['R'],
                data_dict['G'], 
                data_dict['B']
            ], axis=-1)
            
            self.target_data = np.stack([
                data_dict['target_R'],
                data_dict['target_G'],
                data_dict['target_B']
            ], axis=-1)
            
            print(f"测量数据形状: {self.measured_data.shape}")
            print(f"目标数据形状: {self.target_data.shape}")
        
        def rgb_to_xyz(self, rgb):
            """RGB转XYZ色彩空间"""
            rgb_norm = rgb / 255.0
            
            # Gamma校正
            rgb_linear = np.where(rgb_norm <= 0.04045,
                                 rgb_norm / 12.92,
                                 np.power((rgb_norm + 0.055) / 1.055, 2.4))
            
            # sRGB到XYZ的转换矩阵
            transform_matrix = np.array([
                [0.4124564, 0.3575761, 0.1804375],
                [0.2126729, 0.7151522, 0.0721750],
                [0.0193339, 0.1191920, 0.9503041]
            ])
            
            xyz = np.dot(rgb_linear, transform_matrix.T)
            return xyz
        
        def xyz_to_lab(self, xyz):
            """XYZ转CIE Lab色彩空间"""
            # D65白点
            Xn, Yn, Zn = 0.95047, 1.00000, 1.08883
            
            x = xyz[..., 0] / Xn
            y = xyz[..., 1] / Yn
            z = xyz[..., 2] / Zn
            
            # 立方根变换
            fx = np.where(x > 0.008856, np.power(x, 1/3), (7.787 * x + 16/116))
            fy = np.where(y > 0.008856, np.power(y, 1/3), (7.787 * y + 16/116))
            fz = np.where(z > 0.008856, np.power(z, 1/3), (7.787 * z + 16/116))
            
            L = 116 * fy - 16
            a = 500 * (fx - fy)
            b = 200 * (fy - fz)
            
            return np.stack([L, a, b], axis=-1)
        
        def calculate_color_difference(self, lab1, lab2):
            """计算CIE Delta E 2000色差"""
            L1, a1, b1 = lab1[..., 0], lab1[..., 1], lab1[..., 2]
            L2, a2, b2 = lab2[..., 0], lab2[..., 1], lab2[..., 2]
    
            C1 = np.sqrt(a1**2 + b1**2)
            C2 = np.sqrt(a2**2 + b2**2)
            C_bar = 0.5 * (C1 + C2)
    
            G = 0.5 * (1 - np.sqrt(C_bar**7 / (C_bar**7 + 25**7)))
            a1p = (1 + G) * a1
            a2p = (1 + G) * a2
    
            C1p = np.sqrt(a1p**2 + b1**2)
            C2p = np.sqrt(a2p**2 + b2**2)
    
            h1p = np.degrees(np.arctan2(b1, a1p)) % 360
            h1p = np.where(h1p < 0, h1p + 360, h1p) # 确保角度在0-360度
            h2p = np.degrees(np.arctan2(b2, a2p)) % 360
            h2p = np.where(h2p < 0, h2p + 360, h2p)
    
            dLp = L2 - L1
            dCp = C2p - C1p
    
            dhp = h2p - h1p
            dhp = dhp - 360 * (dhp > 180) + 360 * (dhp < -180)
            dHp = 2 * np.sqrt(C1p * C2p) * np.sin(np.radians(dhp / 2))
    
            L_bar = 0.5 * (L1 + L2)
            C_bar_p = 0.5 * (C1p + C2p)
    
            h_bar_p = (h1p + h2p + 360 * (np.abs(h1p - h2p) > 180)) / 2
            h_bar_p %= 360
    
            T = (1
                - 0.17 * np.cos(np.radians(h_bar_p - 30))
                + 0.24 * np.cos(np.radians(2 * h_bar_p))
                + 0.32 * np.cos(np.radians(3 * h_bar_p + 6))
                - 0.20 * np.cos(np.radians(4 * h_bar_p - 63)))
    
            Sl = 1 + (0.015 * (L_bar - 50)**2) / np.sqrt(20 + (L_bar - 50)**2)
            Sc = 1 + 0.045 * C_bar_p
            Sh = 1 + 0.015 * C_bar_p * T
    
            delta_theta = 30 * np.exp(-((h_bar_p - 275)/25)**2)
            Rc = 2 * np.sqrt(C_bar_p**7 / (C_bar_p**7 + 25**7))
            Rt = -np.sin(np.radians(2 * delta_theta)) * Rc
    
            dE = np.sqrt(
                (dLp / Sl)**2 +
                (dCp / Sc)**2 +
                (dHp / Sh)**2 +
                Rt * (dCp / Sc) * (dHp / Sh)
            )
    
            return dE
        
        def estimate_gamma_parameters(self):
            """估计LED的Gamma参数（保留线性比例偏移）"""
            print("正在估计Gamma参数...")
            gamma_params = {}
            for i, channel in enumerate(['R', 'G', 'B']):
                meas = self.measured_data[..., i].flatten() / 255.0
                targ = self.target_data[..., i].flatten() / 255.0
                mask = (targ >= 0) & (targ <= 1)
                m = meas[mask]
                t = targ[mask]
                if len(m) > 0:
                    # 拟合 log(m) = gamma * log(t) + offset
                    A = np.vstack([np.log(t + 1e-8), np.ones_like(t)]).T
                    gamma, offset = np.linalg.lstsq(A, np.log(m + 1e-8), rcond=None)[0]
                    gamma = float(np.clip(gamma, 0.0, 3.0))
                    scale = float(np.exp(offset))
                else:
                    gamma, scale = 1.0, 1.0
                gamma_params[channel] = {'gamma': gamma, 'scale': scale}
                print(f"{channel}通道 Gamma: {gamma:.3f}, Scale: {scale:.3f}")
            self.gamma_correction = gamma_params
            return gamma_params
    
        def apply_gamma_correction(self, rgb_data, inverse=False):
            """应用Gamma校正：在归一化 [0,1] 空间先应用线性比例，再做幂运算"""
            if self.gamma_correction is None:
                return rgb_data
            data = rgb_data.astype(np.float32) / 255.0
            out = np.zeros_like(data)
            for i, channel in enumerate(['R', 'G', 'B']):
                gamma = self.gamma_correction[channel]['gamma']
                scale = self.gamma_correction[channel]['scale']
                ch = data[..., i]
                if not inverse:
                    # 前向：先比例，再幂
                    tmp = ch * scale
                    tmp = np.clip(tmp, 0.0, 1.0)
                    out_ch = np.power(tmp, gamma)
                else:
                    # 反向：开幂，再去比例
                    tmp = np.power(ch, 1.0 / gamma)
                    out_ch = tmp / np.maximum(scale, 1e-8)
                out[..., i] = np.clip(out_ch, 0.0, 1.0)
            # 恢复到 [0,255]
            return (out * 255.0).astype(rgb_data.dtype)
        
        def correction_function(self, params, measured_lin, target_lin):
            """
            优化函数：线性校正矩阵 M 和偏置 b，params 长度 12。
            corrected = clip(M @ measured + b, [0,1])
            计算 ΔE₀₀ + 正则化。
            """
            M = params[:9].reshape(3,3)
            b = params[9:].reshape(1,3)
    
            # 应用矩阵和偏置
            corr = np.dot(measured_lin, M.T) + b
            corr = np.clip(corr, 0.0, 1.0)
    
            # 转到 XYZ → Lab
            transform = np.array([[0.4124564,0.3575761,0.1804375],
                                  [0.2126729,0.7151522,0.0721750],
                                  [0.0193339,0.1191920,0.9503041]])
            tgt_xyz = np.dot(target_lin, transform.T)
            corr_xyz = np.dot(corr, transform.T)
            tgt_lab = self.xyz_to_lab(tgt_xyz.reshape(-1,3)).reshape(corr.shape)
            corr_lab = self.xyz_to_lab(corr_xyz.reshape(-1,3)).reshape(corr.shape)
    
            # 色差
            deltaE = self.calculate_color_difference(tgt_lab, corr_lab)
            loss = np.mean(deltaE)
    
            # 矩阵正则 + 偏置正则
            loss += 0.001 * (np.sum((M - np.eye(3))**2) + np.sum(b**2))
            det = np.linalg.det(M)
            if det <= 0 or abs(det) < 0.1:
                loss += 1000.0
            return loss
        
        def calibrate_correction_matrix(self):
            print("开始校正：矩阵 + 偏置...")
            self.estimate_gamma_parameters()
            # 预处理：线性化
            meas = self.apply_gamma_correction(self.measured_data.astype(np.float32), inverse=True)/255.0
            targ = self.apply_gamma_correction(self.target_data.astype(np.float32), inverse=True)/255.0
            meas_flat = meas.reshape(-1,3)
            targ_flat = targ.reshape(-1,3)
            # 差分进化优化 12 参数
            bounds = [(-2,2)]*9 + [(-0.1,0.1)]*3
            res = differential_evolution(
                self.correction_function, bounds,
                args=(meas_flat, targ_flat), maxiter=200, popsize=15, seed=42
            )
            x0 = res.x
            # 局部 L-BFGS-B
            local = minimize(
                self.correction_function, x0, args=(meas_flat,targ_flat),
                method='L-BFGS-B', options={'maxiter':500}
            )
            M_opt = local.x[:9].reshape(3,3)
            b_opt = local.x[9:].reshape(3)
            self.correction_matrix = M_opt
            self.correction_bias = b_opt
            print("校正完成；矩阵行列式：", np.linalg.det(M_opt))
            print("偏置：", b_opt)
            return M_opt, b_opt
    
        def apply_correction(self, input_rgb):
            """应用带偏置的线性校正"""
            lin = self.apply_gamma_correction(input_rgb.astype(np.float32), inverse=True)/255.0
            flat = lin.reshape(-1,3)
            corr = np.dot(flat, self.correction_matrix.T) + self.correction_bias
            corr = np.clip(corr, 0.0, 1.0).reshape(input_rgb.shape)
            out = (corr * 255.0).astype(np.float32)
            final = self.apply_gamma_correction(out, inverse=False)
            return final.astype(np.uint8)
        
        def evaluate_correction(self):
            """评估校正效果"""
            corrected = self.apply_correction(self.measured_data.astype(np.float32))
            
            measured_xyz = self.rgb_to_xyz(self.measured_data.astype(np.float32))
            corrected_xyz = self.rgb_to_xyz(corrected.astype(np.float32))
            target_xyz = self.rgb_to_xyz(self.target_data.astype(np.float32))
            
            measured_lab = self.xyz_to_lab(measured_xyz)
            corrected_lab = self.xyz_to_lab(corrected_xyz)
            target_lab = self.xyz_to_lab(target_xyz)
            
            diff_before = self.calculate_color_difference(measured_lab, target_lab)
            diff_after = self.calculate_color_difference(corrected_lab, target_lab)
            
            print("="*50)
            print("校正效果评估报告")
            print("="*50)
            print(f"校正前平均色差: {np.mean(diff_before):.3f}")
            print(f"校正后平均色差: {np.mean(diff_after):.3f}")
            print(f"色差改善: {np.mean(diff_before) - np.mean(diff_after):.3f}")
            print(f"改善百分比: {((np.mean(diff_before) - np.mean(diff_after)) / np.mean(diff_before) * 100):.1f}%")
            print(f"校正前最大色差: {np.max(diff_before):.3f}")
            print(f"校正后最大色差: {np.max(diff_after):.3f}")
            print(f"色差<1.0的像素比例: 校正前{np.mean(diff_before < 1.0)*100:.1f}%, 校正后{np.mean(diff_after < 1.0)*100:.1f}%")
            print("="*50)
            
            return corrected, diff_before, diff_after
        
        def visualize_results(self):
            """可视化校正结果"""
            corrected_data = self.apply_correction(self.measured_data.astype(np.float32))
            
            fig, axes = plt.subplots(3, 4, figsize=(20, 15))
            
            # 第一行：测量数据
            for i, (channel, color) in enumerate(zip(['R', 'G', 'B'], ['Reds', 'Greens', 'Blues'])):
                im = axes[0, i].imshow(self.measured_data[:, :, i], cmap=color, vmin=0, vmax=255)
                axes[0, i].set_title(f'测量值 - {channel} 通道')
                axes[0, i].axis('off')
                plt.colorbar(im, ax=axes[0, i], fraction=0.046, pad=0.04)
            
            measured_rgb = np.clip(self.measured_data / 255.0, 0, 1)
            axes[0, 3].imshow(measured_rgb)
            axes[0, 3].set_title('测量值 - RGB合成')
            axes[0, 3].axis('off')
            
            # 第二行：目标数据
            for i, (channel, color) in enumerate(zip(['R', 'G', 'B'], ['Reds', 'Greens', 'Blues'])):
                im = axes[1, i].imshow(self.target_data[:, :, i], cmap=color, vmin=0, vmax=255)
                axes[1, i].set_title(f'目标值 - {channel} 通道')
                axes[1, i].axis('off')
                plt.colorbar(im, ax=axes[1, i], fraction=0.046, pad=0.04)
            
            target_rgb = np.clip(self.target_data / 255.0, 0, 1)
            axes[1, 3].imshow(target_rgb)
            axes[1, 3].set_title('目标值 - RGB合成')
            axes[1, 3].axis('off')
            
            # 第三行：校正后数据
            for i, (channel, color) in enumerate(zip(['R', 'G', 'B'], ['Reds', 'Greens', 'Blues'])):
                im = axes[2, i].imshow(corrected_data[:, :, i], cmap=color, vmin=0, vmax=255)
                axes[2, i].set_title(f'校正后 - {channel} 通道')
                axes[2, i].axis('off')
                plt.colorbar(im, ax=axes[2, i], fraction=0.046, pad=0.04)
            
            corrected_rgb = np.clip(corrected_data / 255.0, 0, 1)
            axes[2, 3].imshow(corrected_rgb)
            axes[2, 3].set_title('校正后 - RGB合成')
            axes[2, 3].axis('off')
            
            plt.tight_layout()
            plt.show()
    
    
    # 主函数
    if __name__ == "__main__":
        files = ["MathModel_Code\\data\\preprocess\\p3\\RedPicture.xlsx", "MathModel_Code\\data\\preprocess\\p3\\GreenPicture.xlsx", "MathModel_Code\\data\\preprocess\\p3\\BluePicture.xlsx"]
        
        corrector = LEDColorCorrection()
        
        for filepath in files:
            corrector.load_excel_data(filepath)
            correction_matrix = corrector.calibrate_correction_matrix()
            
            print("\n评估校正效果:")
            corrected_display, diff_before, diff_after = corrector.evaluate_correction()
            
            corrector.visualize_results()
            
            print("\n校正完成！")
\end{lstlisting}

\newpage
\section[\hspace{-2pt}像素数据集]{{\heiti\zihao{-3} \hspace{-8pt}像素数据集}}

每张表含测量值R，G，B和目标值target\_R，target\_G，target\_B，具体见支撑材料：
\begin{itemize}
    \item \texttt{MathModel\_Code/data/preprocess/RedPicture.xlsx}
    \item \texttt{MathModel\_Code/data/preprocess/GreenPicture.xlsx}  
    \item \texttt{MathModel\_Code/data/preprocess/BluePicture.xlsx}
\end{itemize}

